%!TEX root = std.tex

\definecolor{coegreen}{RGB}{76,187,23}
\definecolor{coedarkgreen}{RGB}{80,170,15}
\definecolor{coered}{RGB}{222,49,99}

\rSec3[indirect.ctor]{Constructors}

\pnum
The following element applies to all functions in~\ref{indirect.ctor}:

\begin{itemdescr}
\pnum
\throws
Nothing unless \tcode{allocator_traits<Allocator>::allocate} or
\tcode{allocator_traits<Alloca\-tor>::construct} throws.
\end{itemdescr}

\indexlibraryctor{indirect}%
\begin{itemdecl}
constexpr explicit indirect();
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{is_default_constructible_v<Allocator>} is \tcode{true}.

\pnum
\mandates
\tcode{is_default_constructible_v<T>} is \tcode{true}.

\pnum
\effects
Constructs an owned object of type \tcode{T} with an empty argument list,
using the allocator \exposid{alloc}.
\end{itemdescr}

\indexlibraryctor{indirect}%
\begin{itemdecl}
constexpr explicit indirect(allocator_arg_t, const Allocator& a);
\end{itemdecl}

\begin{itemdescr}
\pnum
\mandates
\tcode{is_default_constructible_v<T>} is \tcode{true}.

\pnum
\effects
\exposid{alloc} is direct-non-list-initialized with \tcode{a}.
Constructs an owned object of type \tcode{T} with an empty argument list,
using the allocator \exposid{alloc}.
\end{itemdescr}

\indexlibraryctor{indirect}%
\begin{itemdecl}
constexpr indirect(const indirect& other);
\end{itemdecl}

\begin{itemdescr}
\pnum
\mandates
\tcode{is_copy_constructible_v<T>} is \tcode{true}.

\pnum
\effects
\exposid{alloc} is direct-non-list-initialized with
\tcode{allocator_traits<Allocator>::select_on_contai\-ner_copy_construction(other.\exposid{alloc})}.
If \tcode{other} is valueless, \tcode{*this} is valueless.
Otherwise,
constructs an owned object of type \tcode{T} with \tcode{*other},
using the allocator \exposid{alloc}.
\end{itemdescr}

\indexlibraryctor{indirect}%
\begin{itemdecl}
constexpr indirect(allocator_arg_t, const Allocator& a, const indirect& other);
\end{itemdecl}

\begin{itemdescr}
\pnum
\mandates
\tcode{is_copy_constructible_v<T>} is \tcode{true}.

\pnum
\effects
\exposid{alloc} is direct-non-list-initialized with \tcode{a}.
If \tcode{other} is valueless, \tcode{*this} is valueless.
Otherwise,
constructs an owned object of type \tcode{T} with \tcode{*other},
using the allocator \exposid{alloc}.
\end{itemdescr}

\indexlibraryctor{indirect}%
\begin{itemdecl}
constexpr indirect(indirect&& other) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\exposid{alloc} is direct-non-list-initialized from
\tcode{std::move(other.\exposid{alloc})}.
If \tcode{other} is valueless, \tcode{*this} is valueless.
Otherwise \tcode{*this} takes ownership of the owned object of \tcode{other}.

\pnum
\ensures
\tcode{other} is valueless.
\end{itemdescr}

\indexlibraryctor{indirect}%
\begin{itemdecl}
constexpr indirect(allocator_arg_t, const Allocator& a, indirect&& other)
  noexcept(allocator_traits<Allocator>::is_always_equal::value);
\end{itemdecl}

\begin{itemdescr}
\pnum
\mandates
If \tcode{allocator_traits<Allocator>::is_always_equal::value} is \tcode{false}
then \tcode{T} is a complete type.

\pnum
\effects
\exposid{alloc} is direct-non-list-initialized with \tcode{a}.
If \tcode{other} is valueless, \tcode{*this} is valueless.
Otherwise,
if \tcode{\exposid{alloc} == other.\exposid{alloc}} is \tcode{true},
constructs an object of type \tcode{indirect} that
takes ownership of the owned object of \tcode{other}.
Otherwise,
constructs an owned object of type \tcode{T} with \tcode{*std::move(other)},
using the allocator \exposid{alloc}.

\pnum
\ensures
\tcode{other} is valueless.
\end{itemdescr}

\indexlibraryctor{indirect}%
\begin{itemdecl}
template<class U = T>
  constexpr explicit indirect(U&& u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\begin{itemize}
\item
\tcode{is_same_v<remove_cvref_t<U>, indirect>} is \tcode{false},
\item
\tcode{is_same_v<remove_cvref_t<U>, in_place_t>} is \tcode{false},
\item
\textcolor{coered}{\tcode{is_constructible_v<T, U>} is \tcode{true}}, and
\item
\tcode{is_default_constructible_v<Allocator>} is \tcode{true}.
\end{itemize}

\textcolor{coedarkgreen}{
\pnum
\mandates
\begin{itemize}
\item
\tcode{is_constructible_v<T, U>} is \tcode{true}.
\end{itemize}}

\pnum
\effects
Constructs an owned object of type \tcode{T} with \tcode{std::forward<U>(u)},
using the allocator \exposid{alloc}.
\end{itemdescr}

\indexlibraryctor{indirect}%
\begin{itemdecl}
template<class U = T>
  constexpr explicit indirect(allocator_arg_t, const Allocator& a, U&& u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\begin{itemize}
\item
\tcode{is_same_v<remove_cvref_t<U>, indirect>} is \tcode{false},
\item
\tcode{is_same_v<remove_cvref_t<U>, in_place_t>} is \tcode{false}, and
\item
\tcode{is_constructible_v<T, U>} is \tcode{true}.
\end{itemize}

\pnum
\effects
\exposid{alloc} is direct-non-list-initialized with \tcode{a}.
Constructs an owned object of type \tcode{T} with
\tcode{std::forward<U>(u)},
using the allocator \exposid{alloc}.
\end{itemdescr}

\indexlibraryctor{indirect}%
\begin{itemdecl}
template<class... Us>
  constexpr explicit indirect(in_place_t, Us&&... us);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\begin{itemize}
\item
\tcode{is_constructible_v<T, Us...>} is \tcode{true}, and
\item
\tcode{is_default_constructible_v<Allocator>} is \tcode{true}.
\end{itemize}

\pnum
\effects
Constructs an owned object of type \tcode{T} with
\tcode{std::forward<Us>(us)...},
using the allocator \exposid{alloc}.
\end{itemdescr}

\indexlibraryctor{indirect}%
\begin{itemdecl}
template<class... Us>
  constexpr explicit indirect(allocator_arg_t, const Allocator& a,
                              in_place_t, Us&& ...us);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{is_constructible_v<T, Us...>} is \tcode{true}.

\pnum
\effects
\exposid{alloc} is direct-non-list-initialized with \tcode{a}.
Constructs an owned object of type \tcode{T} with
\tcode{std::forward<Us>(us)...},
using the allocator \exposid{alloc}.
\end{itemdescr}

\indexlibraryctor{indirect}%
\begin{itemdecl}
template<class I, class... Us>
  constexpr explicit indirect(in_place_t, initializer_list<I> ilist, Us&&... us);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\begin{itemize}
\item
\tcode{is_constructible_v<T, initializer_list<I>\&, Us...>} is \tcode{true}, and
\item
\tcode{is_default_constructible_v<Allocator>} is \tcode{true}.
\end{itemize}

\pnum
\effects
Constructs an owned object of type \tcode{T} with the arguments
\tcode{ilist, std::forward<Us>(us)...},
using the allocator \exposid{alloc}.
\end{itemdescr}

\indexlibraryctor{indirect}%
\begin{itemdecl}
template<class I, class... Us>
  constexpr explicit indirect(allocator_arg_t, const Allocator& a,
                              in_place_t, initializer_list<I> ilist, Us&&... us);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{is_constructible_v<T, initializer_list<I>\&, Us...>} is \tcode{true}.

\pnum
\effects
\exposid{alloc} is direct-non-list-initialized with \tcode{a}.
Constructs an owned object of type \tcode{T} with the arguments
\tcode{ilist, std::forward<Us>(us)...},
using the allocator \exposid{alloc}.
\end{itemdescr}


\rSec3[polymorphic.ctor]{Constructors}

\pnum
The following element applies to all functions in~\ref{polymorphic.ctor}:

\begin{itemdescr}
\pnum
\throws
Nothing unless \tcode{allocator_traits<Allocator>::allocate} or
\tcode{allocator_traits<Alloca\-tor>::construct} throws.
\end{itemdescr}

\indexlibraryctor{polymorphic}%
\begin{itemdecl}
constexpr explicit polymorphic();
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{is_default_constructible_v<Allocator>} is \tcode{true}.

\pnum
\mandates
\begin{itemize}
\item
\tcode{is_default_constructible_v<T>} is \tcode{true}, and
\item
\tcode{is_copy_constructible_v<T>} is \tcode{true}.
\end{itemize}

\pnum
\effects
Constructs an owned object of type \tcode{T} with an empty argument list
using the allocator \exposid{alloc}.
\end{itemdescr}

\indexlibraryctor{indirect}%
\begin{itemdecl}
constexpr explicit polymorphic(allocator_arg_t, const Allocator& a);
\end{itemdecl}

\begin{itemdescr}
\pnum
\mandates
\begin{itemize}
\item
\tcode{is_default_constructible_v<T>} is \tcode{true}, and
\item
\tcode{is_copy_constructible_v<T>} is \tcode{true}.
\end{itemize}

\pnum
\effects
\exposid{alloc} is direct-non-list-initialized with \tcode{a}.
Constructs an owned object of type \tcode{T} with an empty argument list
using the allocator \exposid{alloc}.
\end{itemdescr}

\indexlibraryctor{polymorphic}%
\begin{itemdecl}
constexpr polymorphic(const polymorphic& other);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\exposid{alloc} is direct-non-list-initialized with
\tcode{allocator_traits<Allocator>::select_on_contai\-ner_copy_construction(other.\exposid{alloc})}.
If \tcode{other} is valueless, \tcode{*this} is valueless.
Otherwise,
constructs an owned object of type \tcode{U}, where
\tcode{U} is the type of the owned object in \tcode{other}, with
the owned object in \tcode{other} using the allocator \exposid{alloc}.
\end{itemdescr}

\indexlibraryctor{polymorphic}%
\begin{itemdecl}
constexpr polymorphic(allocator_arg_t, const Allocator& a, const polymorphic& other);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\exposid{alloc} is direct-non-list-initialized with \tcode{a}.
If \tcode{other} is valueless, \tcode{*this} is valueless.
Otherwise,
constructs an owned object of type \tcode{U}, where
\tcode{U} is the type of the owned object in \tcode{other}, with
the owned object in \tcode{other} using the allocator \exposid{alloc}.
\end{itemdescr}

\indexlibraryctor{polymorphic}%
\begin{itemdecl}
constexpr polymorphic(polymorphic&& other) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\exposid{alloc} is direct-non-list-initialized with
\tcode{std::move(other.\exposid{alloc})}.
If \tcode{other} is valueless, \tcode{*this} is valueless.
Otherwise,
either \tcode{*this}
takes ownership of the owned object of \tcode{other} or,
%FIXME: Cleanup awkward wording.
owns an object of the same type
constructed from the owned object of \tcode{other}
considering that owned object as an rvalue,
using the allocator \exposid{alloc}.
\end{itemdescr}

\indexlibraryctor{polymorphic}%
\begin{itemdecl}
constexpr polymorphic(allocator_arg_t, const Allocator& a, polymorphic&& other)
  noexcept(allocator_traits<Allocator>::is_always_equal::value);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\exposid{alloc} is direct-non-list-initialized with \tcode{a}.
If \tcode{other} is valueless, \tcode{*this} is valueless.
Otherwise,
if \tcode{\exposid{alloc} == other.\exposid{alloc}} is \tcode{true},
either constructs an object of type \tcode{polymorphic} that
owns the owned object of \tcode{other},
making \tcode{other} valueless; or,
%FIXME: Cleanup awkward wording. (And similar wording elsewhere).
owns an object of the same type constructed from
the owned object of \tcode{other}
considering that owned object as an rvalue.
Otherwise,
if \tcode{\exposid{alloc} != other.\exposid{alloc}} is \tcode{true},
constructs an object of type \tcode{polymorphic},
considering the owned object in \tcode{other} as an rvalue,
using the allocator \exposid{alloc}.
\end{itemdescr}

\indexlibraryctor{polymorphic}%
\begin{itemdecl}
template<class U = T>
  constexpr explicit polymorphic(U&& u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
Where \tcode{UU} is \tcode{remove_cvref_t<U>},
\begin{itemize}
\item
\tcode{is_same_v<UU, polymorphic>} is \tcode{false},
\item
\tcode{derived_from<UU, T>} is \tcode{true},
\item
\tcode{is_constructible_v<UU, U>} is \tcode{true},
\item
\tcode{is_copy_constructible_v<UU>} is \tcode{true},
\item
\tcode{UU} is not a specialization of \tcode{in_place_type_t}, and
\item
\tcode{is_default_constructible_v<Allocator>} is \tcode{true}.
\end{itemize}

\pnum
\effects
Constructs an owned object of type \tcode{UU} with \tcode{std::forward<U>(u)}
using the allocator \exposid{alloc}.
\end{itemdescr}

\indexlibraryctor{polymorphic}%
\begin{itemdecl}
template<class U = T>
  constexpr explicit polymorphic(allocator_arg_t, const Allocator& a, U&& u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
Where \tcode{UU} is \tcode{remove_cvref_t<U>},
\begin{itemize}
\item
\tcode{is_same_v<UU, polymorphic>} is \tcode{false},
\item
\tcode{derived_from<UU, T>} is \tcode{true},
\item
\tcode{is_constructible_v<UU, U>} is \tcode{true},
\item
\tcode{is_copy_constructible_v<UU>} is \tcode{true}, and
\item
\tcode{UU} is not a specialization of \tcode{in_place_type_t}.
\end{itemize}

\pnum
\effects
\exposid{alloc} is direct-non-list-initialized with \tcode{a}.
Constructs an owned object of type \tcode{UU} with \tcode{std::forward<U>(u)}
using the allocator \exposid{alloc}.
\end{itemdescr}

\indexlibraryctor{polymorphic}%
\begin{itemdecl}
template<class U, class... Ts>
  constexpr explicit polymorphic(in_place_type_t<U>, Ts&&... ts);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\begin{itemize}
\item
\tcode{is_same_v<remove_cvref_t<U>, U>} is \tcode{true},
\item
\tcode{derived_from<U, T>} is \tcode{true},
\item
\tcode{is_constructible_v<U, Ts...>} is \tcode{true},
\item
\tcode{is_copy_constructible_v<U>} is \tcode{true}, and
\item
\tcode{is_default_constructible_v<Allocator>} is \tcode{true}.
\end{itemize}

\pnum
\effects
Constructs an owned object of type \tcode{U} with
\tcode{std::forward<Ts>(ts)...}
using the allocator \exposid{alloc}.
\end{itemdescr}

\indexlibraryctor{polymorphic}%
\begin{itemdecl}
template<class U, class... Ts>
  constexpr explicit polymorphic(allocator_arg_t, const Allocator& a,
                                 in_place_type_t<U>, Ts&&... ts);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\begin{itemize}
\item
\tcode{is_same_v<remove_cvref_t<U>, U>} is \tcode{true},
\item
\tcode{derived_from<U, T>} is \tcode{true},
\item
\tcode{is_constructible_v<U, Ts...>} is \tcode{true}, and
\item
\tcode{is_copy_constructible_v<U>} is \tcode{true}.
\end{itemize}

\pnum
\effects
\exposid{alloc} is direct-non-list-initialized with \tcode{a}.
Constructs an owned object of type \tcode{U} with
\tcode{std::forward<Ts>(ts)...}
using the allocator \exposid{alloc}.
\end{itemdescr}

\indexlibraryctor{polymorphic}%
\begin{itemdecl}
template<class U, class I, class... Us>
  constexpr explicit polymorphic(in_place_type_t<U>, initializer_list<I> ilist, Us&&... us);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\begin{itemize}
\item
\tcode{is_same_v<remove_cvref_t<U>, U>} is \tcode{true},
\item
\tcode{derived_from<U, T>} is \tcode{true},
\item
\tcode{is_constructible_v<U, initializer_list<I>\&, Us...>} is \tcode{true},
\item
\tcode{is_copy_constructible_v<U>} is \tcode{true}, and
\item
\tcode{is_default_constructible_v<Allocator>} is \tcode{true}.
\end{itemize}

\pnum
\effects
Constructs an owned object of type \tcode{U} with
the arguments \tcode{ilist, std::forward<Us>(us)...}
using the allocator \exposid{alloc}.
\end{itemdescr}

\indexlibraryctor{polymorphic}%
\begin{itemdecl}
template<class U, class I, class... Us>
  constexpr explicit polymorphic(allocator_arg_t, const Allocator& a,
                                 in_place_type_t<U>, initializer_list<I> ilist, Us&&... us);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints

\begin{itemize}
\item
\tcode{is_same_v<remove_cvref_t<U>, U>} is \tcode{true},
\item
\tcode{derived_from<U, T>} is \tcode{true},
\item
\tcode{is_constructible_v<U, initializer_list<I>\&, Us...>} is \tcode{true}, and
\item
\tcode{is_copy_constructible_v<U>} is \tcode{true}.
\end{itemize}

\pnum
\effects
\exposid{alloc} is direct-non-list-initialized with \tcode{a}.
Constructs an owned object of type \tcode{U} with the arguments
\tcode{ilist, std::forward<Us>(us)...}
using the allocator \exposid{alloc}.
\end{itemdescr}
