<h1
id="constraints-on-incomplete-types-in-indirect-and-polymorphic">Constraints
on incomplete types in <code>indirect</code> and
<code>polymorphic</code></h1>
<p><strong>Section:</strong> 20.4 <code>[mem.composite.types]</code></p>
<p><strong>Submitter:</strong> Jonathan B. Coe <a
href="mailto:jonathanbcoe@gmail.com"
class="email">jonathanbcoe@gmail.com</a></p>
<p><strong>Coauthors:</strong> Antony Peacock <a
href="mailto:ant.peacock@gmail.com"
class="email">ant.peacock@gmail.com</a></p>
<p><strong>Opened:</strong> 2025-08-16</p>
<h2 id="problem">Problem</h2>
<p>The class templates <code>indirect&lt;T&gt;</code> and
<code>polymorphic&lt;T&gt;</code> allow the template argument
<code>T</code> to be an incomplete type.</p>
<p>Both classes can be instantiated when the type <code>T</code> is
incomplete: constraints are written so that requirements on incomplete
types are not evaluated at class instantiation time.</p>
<p>For constructors with additional template parameters, there are
currently constraints written on the potentially incomplete type
<code>T</code> and the additional template parameters. Such constraints
will not be evaluated at class instantiation time but could be
explicitly evaluated in contexts where support for an incomplete
<code>T</code> is required.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    U u<span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    A<span class="op">(</span><span class="at">const</span> SomeType<span class="op">&amp;)</span> <span class="kw">requires</span> <span class="bu">std::</span>is_constructible_v<span class="op">&lt;</span>U<span class="op">,</span> SomeType<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ...</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>when <code>U</code> is <code>indirect&lt;T&gt;</code> or
<code>polymorphic&lt;T&gt;</code> for some type <code>T</code>, the
existence of the <code>requires</code> clause will require that
<code>T</code> is a complete type for constraints on
<code>indirect</code> or <code>polymorphic</code> to be evaluated.</p>
<h2 id="proposed-changes">Proposed Changes</h2>
<p><em>Constraints</em> on <code>T</code> should be converted to
<em>Mandates</em> on <code>T</code> so that constraint evaluation does
not require <code>T</code> to be a complete type.</p>
<h3 id="changes-to-indirect">Changes to <code>indirect</code></h3>
<p>Modify <code>indirect</code> constructors
<code>[indirect.ctor]</code> as indicated:</p>
<div
style="border-width:1px; border-style:solid; border-color:#636363; padding: 1em;">
<div class="sourceCode" id="cb2"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> U <span class="op">=</span> T<span class="op">&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">explicit</span> indirect<span class="op">(</span>U<span class="op">&amp;&amp;</span> u<span class="op">);</span></span></code></pre></div>
<p><em>Constraints</em>:</p>
<ul>
<li><code>is_same_v&lt;remove_cvref_t&lt;U&gt;, indirect&gt;</code> is
<code>false</code>,</li>
<li><code>is_same_v&lt;remove_cvref_t&lt;U&gt;, in_place_t&gt;</code> is
<code>false</code>,</li>
<li><s style="background-color: pink;">
<code>is_constructible_v&lt;T, U&gt;</code> is <code>true</code></s>,
and</li>
<li><code>is_default_constructible_v&lt;Allocator&gt;</code> is
<code>true</code>.</li>
</ul>
<p><u style="background-color: lightgreen;"> <em>Mandates</em>:
<code>is_constructible_v&lt;T, U&gt;</code> is
<code>true</code>.</u></p>
<p><em>Effects</em>: Constructs an owned object of type <code>T</code>
with <code>std::forward&lt;U&gt;(u)</code>, using the allocator
<code>alloc</code>.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> U <span class="op">=</span> T<span class="op">&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">explicit</span> indirect<span class="op">(</span><span class="dt">allocator_arg_t</span><span class="op">,</span> <span class="at">const</span> Allocator<span class="op">&amp;</span> a<span class="op">,</span> U<span class="op">&amp;&amp;</span> u<span class="op">);</span></span></code></pre></div>
<p><em>Constraints</em>:</p>
<ul>
<li><code>is_same_v&lt;remove_cvref_t&lt;U&gt;, indirect&gt;</code> is
<code>false</code>,</li>
<li><code>is_same_v&lt;remove_cvref_t&lt;U&gt;, in_place_t&gt;</code> is
<code>false</code>, and</li>
<li><s style="background-color: pink;">
<code>is_constructible_v&lt;T, U&gt;</code> is
<code>true</code>.</s></li>
</ul>
<p><u style="background-color: lightgreen;"> <em>Mandates</em>:
<code>is_constructible_v&lt;T, U&gt;</code> is
<code>true</code>.</u></p>
<p><em>Effects</em>: <code>alloc</code> is direct-non-list-initialized
with <code>a</code>. Constructs an owned object of type <code>T</code>
with <code>std::forward&lt;U&gt;(u)</code>, using the allocator
<code>alloc</code>.</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span><span class="op">...</span> Us<span class="op">&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">explicit</span> indirect<span class="op">(</span><span class="dt">in_place_t</span><span class="op">,</span> Us<span class="op">&amp;&amp;...</span> us<span class="op">);</span></span></code></pre></div>
<p><em>Constraints</em>:</p>
<ul>
<li><s style="background-color: pink;"><code>is_constructible_v&lt;T, Us...&gt;</code>
is <code>true</code>, and </s></li>
<li><code>is_default_constructible_v&lt;Allocator&gt;</code> is
<code>true</code>.</li>
</ul>
<p><u style="background-color: lightgreen;"><em>Mandates</em>:
<code>is_constructible_v&lt;T, Us ... &gt;</code> is
<code>true</code>.</u></p>
<p><em>Effects</em>: Constructs an owned object of type <code>T</code>
with <code>std::forward&lt;Us&gt;(us)...</code>, using the allocator
<code>alloc</code>.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span><span class="op">...</span> Us<span class="op">&gt;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">explicit</span> indirect<span class="op">(</span><span class="dt">allocator_arg_t</span><span class="op">,</span> <span class="at">const</span> Allocator<span class="op">&amp;</span> a<span class="op">,</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="dt">in_place_t</span><span class="op">,</span> Us<span class="op">&amp;&amp;</span> <span class="op">...</span>us<span class="op">);</span></span></code></pre></div>
<p><s style="background-color: pink;"><em>Constraints</em>:
<code>is_constructible_v&lt;T, Us...&gt;</code> is
<code>true</code>.</s></p>
<p><u style="background-color: lightgreen;"><em>Mandates</em>:
<code>is_constructible_v&lt;T, Us...&gt;</code> is
<code>true</code>.</u></p>
<p><em>Effects</em>: <code>alloc</code> is direct-non-list-initialized
with <code>a</code>. Constructs an owned object of type <code>T</code>
with <code>std::forward&lt;Us&gt;(us)...</code>, using the allocator
<code>alloc</code>.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> I<span class="op">,</span> <span class="kw">class</span><span class="op">...</span> Us<span class="op">&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">explicit</span> indirect<span class="op">(</span><span class="dt">in_place_t</span><span class="op">,</span> initializer_list<span class="op">&lt;</span>I<span class="op">&gt;</span> ilist<span class="op">,</span> Us<span class="op">&amp;&amp;...</span> us<span class="op">);</span></span></code></pre></div>
<p><em>Constraints</em>:</p>
<ul>
<li><s style="background-color: pink;">
<code>is_constructible_v&lt;T, initializer_list&lt;I&gt;&amp;, Us...&gt;</code>
is <code>true</code>, and</s></li>
<li><code>is_default_constructible_v&lt;Allocator&gt;</code> is
<code>true</code>.</li>
</ul>
<p><u style="background-color: lightgreen;"><em>Mandates</em>:
<code>is_constructible_v&lt;T, initializer_list&lt;I&gt;&amp;, Us...&gt;</code>
is <code>true</code>.</u></p>
<p><em>Effects</em>: Constructs an owned object of type <code>T</code>
with the arguments <code>ilist</code>,
<code>std::forward&lt;Us&gt;(us)...</code>, using the allocator
<code>alloc</code>.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> I<span class="op">,</span> <span class="kw">class</span><span class="op">...</span> Us<span class="op">&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">explicit</span> indirect<span class="op">(</span><span class="dt">allocator_arg_t</span><span class="op">,</span> <span class="at">const</span> Allocator<span class="op">&amp;</span> a<span class="op">,</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="dt">in_place_t</span><span class="op">,</span> initializer_list<span class="op">&lt;</span>I<span class="op">&gt;</span> ilist<span class="op">,</span> Us<span class="op">&amp;&amp;...</span> us<span class="op">);</span></span></code></pre></div>
<p><s style="background-color: pink;"><em>Constraints</em>:
<code>is_constructible_v&lt;T, initializer_list&lt;I&gt;&amp;, Us...&gt;</code>
is <code>true</code>.</s></p>
<p><u style="background-color: lightgreen;"><em>Mandates</em>:
<code>is_constructible_v&lt;T, initializer_list&lt;I&gt;&amp;, Us...&gt;</code>
is <code>true</code>.</u></p>
<p><em>Effects</em>: <code>alloc</code> is direct-non-list-initialized
with <code>a</code>. Constructs an owned object of type <code>T</code>
with the arguments <code>ilist</code>,
<code>std::forward&lt;Us&gt;(us)...</code>, using the allocator
<code>alloc</code>.</p>
</div>
<h3 id="changes-to-polymorphic">Changes to <code>polymorphic</code></h3>
<p>Modify <code>polymorphic</code> constructors as indicated:</p>
<div
style="border-width:1px; border-style:solid; border-color:#636363; padding: 1em;">
<div class="sourceCode" id="cb8"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> U <span class="op">=</span> T<span class="op">&gt;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">explicit</span> polymorphic<span class="op">(</span>U<span class="op">&amp;&amp;</span> u<span class="op">);</span></span></code></pre></div>
<p><em>Constraints</em>: Where <code>UU</code> is
<code>remove_cvref_t&lt;U&gt;</code>,</p>
<ul>
<li><code>is_same_v&lt;UU, polymorphic&gt;</code> is
<code>false</code>,</li>
<li><s style="background-color: pink;"><code>derived_from&lt;UU, T&gt;</code>
is <code>true</code></s>,</li>
<li><code>is_constructible_v&lt;UU, U&gt;</code> is
<code>true</code>,</li>
<li><code>is_copy_constructible_v&lt;UU&gt;</code> is
<code>true</code>,</li>
<li><code>UU</code> is not a specialization of
<code>in_place_type_t</code>, and</li>
<li><code>is_default_constructible_v&lt;Allocator&gt;</code> is
<code>true</code>.</li>
</ul>
<p><u style="background-color: lightgreen;"><em>Mandates</em>:
<code>derived_from&lt;UU, T&gt;</code> is <code>true</code>.</u></p>
<p><em>Effects</em>: Constructs an owned object of type <code>UU</code>
with <code>std::forward&lt;U&gt;(u)</code> using the allocator
<code>alloc</code>.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> U <span class="op">=</span> T<span class="op">&gt;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">explicit</span> polymorphic<span class="op">(</span><span class="dt">allocator_arg_t</span><span class="op">,</span> <span class="at">const</span> Allocator<span class="op">&amp;</span> a<span class="op">,</span> U<span class="op">&amp;&amp;</span> u<span class="op">);</span></span></code></pre></div>
<p><em>Constraints</em>: Where <code>UU</code> is
<code>remove_cvref_t&lt;U&gt;</code>,</p>
<ul>
<li><code>is_same_v&lt;UU, polymorphic&gt;</code> is
<code>false</code>,</li>
<li><s style="background-color: pink;"><code>derived_from&lt;UU, T&gt;</code>
is <code>true</code></s>,</li>
<li><code>is_constructible_v&lt;UU, U&gt;</code> is
<code>true</code>,</li>
<li><code>is_copy_constructible_v&lt;UU&gt;</code> is <code>true</code>,
and</li>
<li><code>UU</code> is not a specialization of
<code>in_place_type_t</code>.</li>
</ul>
<p><u style="background-color: lightgreen;"><em>Mandates</em>:
<code>derived_from&lt;UU, T&gt;</code> is <code>true</code>.</u></p>
<p><em>Effects</em>: <code>alloc</code> is direct-non-list-initialized
with <code>a</code>. Constructs an owned object of type <code>UU</code>
with <code>std::forward&lt;U&gt;(u)</code> using the allocator
<code>alloc</code>.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> U<span class="op">,</span> <span class="kw">class</span><span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">explicit</span> polymorphic<span class="op">(</span><span class="dt">in_place_type_t</span><span class="op">&lt;</span>U<span class="op">&gt;,</span> Ts<span class="op">&amp;&amp;...</span> ts<span class="op">);</span></span></code></pre></div>
<p><em>Constraints</em>:</p>
<ul>
<li><code>is_same_v&lt;remove_cvref_t&lt;U&gt;, U&gt;</code> is
<code>true</code>,</li>
<li><s style="background-color: pink;"><code>derived_from&lt;U, T&gt;</code>
is <code>true</code></s>,</li>
<li><code>is_constructible_v&lt;U, Ts...&gt;</code> is
<code>true</code>,</li>
<li><code>is_copy_constructible_v&lt;U&gt;</code> is <code>true</code>,
and</li>
<li><code>is_default_constructible_v&lt;Allocator&gt;</code> is
<code>true</code>.</li>
</ul>
<p><u style="background-color: lightgreen;"><em>Mandates</em>:
<code>derived_from&lt;U, T&gt;</code> is <code>true</code>.</u></p>
<p><em>Effects</em>: Constructs an owned object of type <code>U</code>
with <code>std::forward&lt;Ts&gt;(ts)...</code> using the allocator
<code>alloc</code>.</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> U<span class="op">,</span> <span class="kw">class</span><span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">explicit</span> polymorphic<span class="op">(</span><span class="dt">allocator_arg_t</span><span class="op">,</span> <span class="at">const</span> Allocator<span class="op">&amp;</span> a<span class="op">,</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>                               <span class="dt">in_place_type_t</span><span class="op">&lt;</span>U<span class="op">&gt;,</span> Ts<span class="op">&amp;&amp;...</span> ts<span class="op">);</span></span></code></pre></div>
<p><em>Constraints</em>:</p>
<ul>
<li><code>is_same_v&lt;remove_cvref_t&lt;U&gt;, U&gt;</code> is
<code>true</code>,</li>
<li><s style="background-color: pink;"><code>derived_from&lt;U, T&gt;</code>
is <code>true</code></s>,</li>
<li><code>is_constructible_v&lt;U, Ts...&gt;</code> is
<code>true</code>, and</li>
<li><code>is_copy_constructible_v&lt;U&gt;</code> is
<code>true</code>.</li>
</ul>
<p><u style="background-color: lightgreen;"><em>Mandates</em>:
<code>derived_from&lt;U, T&gt;</code> is <code>true</code>.</u></p>
<p><em>Effects</em>: <code>alloc</code> is direct-non-list-initialized
with <code>a</code>. Constructs an owned object of type <code>U</code>
with <code>std::forward&lt;Ts&gt;(ts)...</code> using the allocator
<code>alloc</code>.</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> U<span class="op">,</span> <span class="kw">class</span> I<span class="op">,</span> <span class="kw">class</span><span class="op">...</span> Us<span class="op">&gt;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">explicit</span> polymorphic<span class="op">(</span><span class="dt">in_place_type_t</span><span class="op">&lt;</span>U<span class="op">&gt;,</span> initializer_list<span class="op">&lt;</span>I<span class="op">&gt;</span> ilist<span class="op">,</span> Us<span class="op">&amp;&amp;...</span> us<span class="op">);</span></span></code></pre></div>
<p><em>Constraints</em>:</p>
<ul>
<li><code>is_same_v&lt;remove_cvref_t&lt;U&gt;, U&gt;</code> is
<code>true</code>,</li>
<li><s style="background-color: pink;"><code>derived_from&lt;U, T&gt;</code>
is <code>true</code></s>,</li>
<li><code>is_constructible_v&lt;U, initializer_list&lt;I&gt;&amp;, Us...&gt;</code>
is <code>true</code>,</li>
<li><code>is_copy_constructible_v&lt;U&gt;</code> is <code>true</code>,
and</li>
<li><code>is_default_constructible_v&lt;Allocator&gt;</code> is
<code>true</code>.</li>
</ul>
<p><u style="background-color: lightgreen;"><em>Mandates</em>:
<code>derived_from&lt;U, T&gt;</code> is <code>true</code>.</u></p>
<p><em>Effects</em>: Constructs an owned object of type <code>U</code>
with the arguments <code>ilist</code>,
<code>std::forward&lt;Us&gt;(us)...</code> using the allocator
<code>alloc</code>.</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> U<span class="op">,</span> <span class="kw">class</span> I<span class="op">,</span> <span class="kw">class</span><span class="op">...</span> Us<span class="op">&gt;</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">explicit</span> polymorphic<span class="op">(</span><span class="dt">allocator_arg_t</span><span class="op">,</span> <span class="at">const</span> Allocator<span class="op">&amp;</span> a<span class="op">,</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>                               <span class="dt">in_place_type_t</span><span class="op">&lt;</span>U<span class="op">&gt;,</span> initializer_list<span class="op">&lt;</span>I<span class="op">&gt;</span> ilist<span class="op">,</span> Us<span class="op">&amp;&amp;...</span> us<span class="op">);</span></span></code></pre></div>
<p><em>Constraints</em>:</p>
<ul>
<li><code>is_same_v&lt;remove_cvref_t&lt;U&gt;, U&gt;</code> is
<code>true</code>,</li>
<li><s style="background-color: pink;"><code>derived_from&lt;U, T&gt;</code>
is <code>true</code></s>,</li>
<li><code>is_constructible_v&lt;U, initializer_list&lt;I&gt;&amp;, Us...&gt;</code>
is <code>true</code>, and</li>
<li><code>is_copy_constructible_v&lt;U&gt;</code> is
<code>true</code>.</li>
</ul>
<p><u style="background-color: lightgreen;"><em>Mandates</em>:
<code>derived_from&lt;U, T&gt;</code> is <code>true</code>.</u></p>
<p><em>Effects</em>: <code>alloc</code> is direct-non-list-initialized
with <code>a</code>. Constructs an owned object of type <code>U</code>
with the arguments <code>ilist</code>,
<code>std::forward&lt;Us&gt;(us)...</code> using the allocator
<code>alloc</code>.</p>
</div>
